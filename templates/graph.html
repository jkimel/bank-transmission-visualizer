{% extends "base.html" %}

{% block title %}Visualización de Grafo - Ruta Mínima{% endblock %}

{% block extra_css %}
{% endblock %}
{% block content %}
<div class="row">
    <div class="col-12">
        <div class="card border-0 shadow-sm">
            <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                <h4 class="card-title mb-0">
                    <i class="fas fa-project-diagram me-2"></i>Análisis de Latencia (Ruta Más Corta)
                </h4>
                <a href="{{ url_for('table_page') }}" class="btn btn-dark btn-sm">
                    <i class="fas fa-arrow-left me-1"></i>Volver a la Tabla
                </a>
            </div>
            <div class="card-body">
                <div class="graph-controls mb-4">
                    <div class="row align-items-end">
                        <div class="col-md-3">
                            <label class="form-label small fw-bold">Origen</label>
                            <select id="selectOrigen" class="form-select form-select-sm"></select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label small fw-bold">Destino</label>
                            <select id="selectDestino" class="form-select form-select-sm"></select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label small fw-bold">Paradas Intermedias (separadas por coma)</label>
                            <input type="text" id="inputParadas" class="form-control form-control-sm" placeholder="Ej: R3,R7">
                        </div>
                        <div class="col-md-3 d-flex">
                            <button id="btnBuscarRuta" class="btn btn-primary btn-sm w-100 me-2">
                                <i class="fas fa-route me-1"></i>Buscar Ruta
                            </button>
                            <button id="btnReset" class="btn btn-secondary btn-sm w-100">
                                <i class="fas fa-redo"></i> Resetear
                            </button>
                        </div>
                    </div>
                </div>

                <div id="resultadoRuta" class="alert d-none mb-4"></div>

                <div id="network" style="width: 100%; height: 600px; border: 1px solid #ddd;"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

<script>
class GraphManager {
    constructor() {
        this.network = null;
        this.nodes = new vis.DataSet();
        this.edges = new vis.DataSet();
        
        this.container = document.getElementById('network');
        
        if (this.container) {
            this.container.style.width = '100%';
            this.container.style.height = '75vh'; 
            this.container.style.border = '1px solid #e0e0e0';
            this.container.style.borderRadius = '8px';
            this.container.style.backgroundColor = '#fafafa';
        }

        this.originalNodesData = [];
        this.originalEdgesData = [];
        this.isPathActive = false; 
        
        this.init();
    }

    async init() {
        if (!this.container) return;
        await this.loadGraphData();
        this.initGraph();
        this.initEventListeners();
        this.setupHoverEvents(); 
        this.resetHighlight(false);
    }

    async loadGraphData() {
        try {
            const response = await fetch("/api/graph");
            const data = await response.json();

            if (response.ok) {
                this.originalNodesData = data.nodes;
                this.originalEdgesData = data.edges;
                this.renderGraph(data);
                this.populateNodeSelects(data.all_nodes);
            } else {
                this.showResult('Error cargando datos: ' + data.error, 'danger');
            }
        } catch (error) {
            this.showResult('Error de conexión', 'danger');
        }
    }

    getLatencyColor(latencia) {
        if (latencia < 15) return '#00C853'; 
        if (latencia <= 35) return '#FDD835'; 
        return '#D50000'; 
    }

    renderGraph(data) {
        this.nodes.clear();
        this.edges.clear();
        
        // Nodos limpios (sin popup title)
        const cleanNodes = data.nodes.map(n => ({
            id: n.id, label: n.label,
            font: { 
                size: 50,  // <--- TAMAÑO GIGANTE FIJO
                face: 'Arial',
                color: '#000000'
            },
            // Desactiva que el grafo intente ajustar el texto automáticamente
            scaling: { 
                label: { 
                    enabled: false 
                } 
            },
            margin: 20 // Espacio extra
        }));

        this.nodes.add(cleanNodes);

        // Aristas con popup de latencia
        const processedEdges = data.edges.map(edge => {
            const latencia = parseFloat(edge.weight);
            const colorCode = this.getLatencyColor(latencia);
            
            return {
                ...edge,
                id: edge.id, 
                originalColor: colorCode,
                color: {
                    color: colorCode,
                    highlight: colorCode,
                    hover: colorCode,
                    opacity: 1.0
                },
                width: 9, // Grosor normal
                font: { size: 0, color: 'transparent' },
                title: `⏱ Latencia: ${latencia} ms`,
                shadow: { enabled: false }
            };
        });

        this.edges.add(processedEdges);
        this.originalEdgesData = processedEdges; 
    }

    populateNodeSelects(nodes) {
        nodes.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
        const selectOrigen = document.getElementById('selectOrigen');
        const selectDestino = document.getElementById('selectDestino');
        selectOrigen.innerHTML = '<option value="">-- Seleccionar Origen --</option>';
        selectDestino.innerHTML = '<option value="">-- Seleccionar Destino --</option>';
        nodes.forEach(node => {
            selectOrigen.add(new Option(node, node));
            selectDestino.add(new Option(node, node));
        });
    }

    initGraph() {
        const data = { nodes: this.nodes, edges: this.edges };
        const options = {
            autoResize: true, height: '100%', width: '100%',
            layout: { 
                hierarchical: { enabled: false },
                randomSeed: 5
            },
            physics: {
                enabled: true,
                solver: 'forceAtlas2Based',
                forceAtlas2Based: {
                    gravitationalConstant: -300, 
                    // AJUSTE 1: Un poco más de gravedad para anclar el centro
                    centralGravity: 0.005, 
                    springLength: 300,
                    // AJUSTE 2: Resortes más suaves para evitar el efecto látigo
                    springConstant: 0.05, 
                    avoidOverlap: 1,
                    // AJUSTE 3: Fricción MÁXIMA (Cemento). Esto mata el giro.
                    damping: 1.0 
                },
                minVelocity: 0.1, // Detenerse ante el mínimo movimiento
                maxVelocity: 30,  // No permitir movimientos bruscos
                stabilization: { 
                    enabled: true, 
                    iterations: 2000, 
                    updateInterval: 50,
                    fit: true 
                }
            },
            interaction: { 
                hover: true, 
                zoomView: true, dragView: true, dragNodes: true,
                selectable: false, selectConnectedEdges: false,
                zoomSpeed: 0.4 
            },
            nodes: {
                shape: 'box', 
                font: { size: 48, face: 'Arial', color: '#000' }, 
                color: { background: '#ffffff', border: '#455a64' },
                borderWidth: 1, 
                shadow: { enabled: true, color: 'rgba(0,0,0,0.2)', size: 5, x: 3, y: 3 },
                margin: 15, widthConstraint: { maximum: 200 },
                chosen: false 
            },
            edges: { 
                arrows: 'to', 
                smooth: { type: 'curvedCW', roundness: 0.2 },
                chosen: false 
            }
        };
        this.network = new vis.Network(this.container, data, options);
        
        // TRUCO EXTRA: Si todavía se mueve, congelamos las físicas al terminar de cargar
        this.network.on("stabilizationIterationsDone", function () {
            this.setOptions( { physics: false } );
        });
    }

    // --- NUEVA LÓGICA DE HOVER ---
    setupHoverEvents() {
        this.network.on("hoverNode", (params) => {
            if (this.isPathActive) return;

            this.network.canvas.body.container.style.cursor = 'pointer';
            const connectedEdges = this.network.getConnectedEdges(params.node);
            
            // Ponemos en negrita las conexiones
            const edgesToUpdate = connectedEdges.map(id => ({
                id: id,
                width: 11, 
                shadow: { enabled: true, color: 'rgba(0,0,0,0.2)', size: 3, x: 1, y: 1 }
            }));
            
            this.edges.update(edgesToUpdate);
        });

        this.network.on("blurNode", (params) => {
            if (this.isPathActive) return;

            this.network.canvas.body.container.style.cursor = 'default';
            const connectedEdges = this.network.getConnectedEdges(params.node);
            
            // Volvemos al estado normal
            const edgesToReset = connectedEdges.map(id => ({
                id: id,
                width: 6, 
                shadow: { enabled: false }
            }));
            
            this.edges.update(edgesToReset);
        });
    }

    initEventListeners() {
        document.getElementById('btnBuscarRuta').addEventListener('click', () => this.findPath());
        document.getElementById('btnReset').addEventListener('click', () => this.resetHighlight());
    }

    async findPath() {
        const source = document.getElementById('selectOrigen').value;
        const target = document.getElementById('selectDestino').value;
        const stops = document.getElementById('inputParadas').value;

        if (!source || !target) {
            this.showResult('Selecciona Origen y Destino.', 'warning'); return;
        }
        
        this.showResult('<i class="fas fa-spinner fa-spin"></i> Calculando...', 'info');
        const params = new URLSearchParams({ source, target, stops });
        
        try {
            const response = await fetch(`/api/find_shortest_path?${params}`);
            const result = await response.json();

            if (response.ok) {
                this.highlightPath(result.path, result.edges);
                this.showResult(`✅ Ruta: ${result.path.join(' → ')} | Latencia: <span class="fw-semibold">${result.latency} ms</span>`, 'success');
            } else {
                this.resetHighlight(false);
                this.showResult(`Error: ${result.error}`, 'danger');
            }
        } catch (error) {
            this.resetHighlight(false);
            this.showResult('Error de conexión', 'danger');
        }
    }

    highlightPath(path, edgesInPath) {
        this.isPathActive = true; 

        // 1. LÍNEAS (ARISTAS)
        const edgesToUpdate = this.edges.get().map(graphEdge => {
            const isPartOfPath = edgesInPath.some(pathEdge => 
                String(pathEdge.from) === String(graphEdge.from) && 
                String(pathEdge.to) === String(graphEdge.to)
            );

            if (isPartOfPath) {
                // --- CAMINO SELECCIONADO ---
                return {
                    id: graphEdge.id,
                    color: { color: graphEdge.originalColor, opacity: 1 },
                    width: 10, 
                    shadow: { enabled: true, color: 'rgba(0,0,0,0.4)', size: 4, x: 3, y: 3 },
                    font: { 
                        size: 30, 
                        color: '#000', 
                        strokeWidth: 5, 
                        strokeColor: '#fff', 
                        background: 'none' 
                    },
                    z: 200
                };
            } else {
                // --- RESTO DEL GRAFO (FONDO) ---
                return {
                    id: graphEdge.id,
                    color: { color: graphEdge.originalColor, opacity: 0.2 }, 
                    width: 7, 
                    shadow: { enabled: false },
                    font: { size: 0, color: 'transparent' }, 
                    z: 0
                };
            }
        });
        this.edges.update(edgesToUpdate);

        // 2. NODOS (VÉRTICES)
        const nodesToUpdate = this.nodes.get().map(node => {
            if (path.includes(node.id)) {
                // --- NODO DEL CAMINO ---
                return { 
                    id: node.id, 
                    color: { background: '#ffffff', border: '#000000' }, 
                    borderWidth: 4, // Borde más grueso para destacar
                    // MANTENEMOS EL TAMAÑO 50 QUE TE GUSTÓ
                    font: { size: 50, color: '#000', face: 'Arial' }, 
                    shadow: { enabled: true, size: 8, x: 4, y: 4, color: 'rgba(0,0,0,0.3)' },
                    scaling: { label: { enabled: false } }
                };
            }
            return { 
                id: node.id, 
                // --- NODO DE FONDO ---
                color: { background: '#f5f5f5', border: '#eceff1' },
                borderWidth: 1,
                // Mantenemos tamaño 50 pero en gris para que no "baile" el grafo
                font: { size: 50, color: '#cfd8dc' }, 
                shadow: { enabled: false }
            };
        });
        this.nodes.update(nodesToUpdate);
        
        this.network.fit({ nodes: path, animation: { duration: 1000, easingFunction: 'easeInOutCubic' } });
    }
    resetHighlight(shouldResetResult = true) {
        this.isPathActive = false; 

        if (shouldResetResult) {
            this.showResult('Selecciona ruta.', 'info');
            this.network.fit();
        }
        
        // AQUÍ ESTABA EL PROBLEMA:
        this.nodes.update(this.originalNodesData.map(node => ({
            id: node.id, 
            color: { background: '#ffffff', border: '#455a64' },
            // CAMBIA EL 16 POR 50 AQUÍ TAMBIÉN:
            font: { size: 50, color: '#000', face: 'Arial' }, 
            borderWidth: 1, 
            shadow: { enabled: true, color: 'rgba(0,0,0,0.2)', size: 5, x: 3, y: 3 },
            // Asegúrate de volver a desactivar el escalado aquí para que se mantenga grande
            scaling: { label: { enabled: false } },
            margin: 20
        })));

        if (this.originalEdgesData.length > 0) {
            const cleanEdges = this.originalEdgesData.map(e => ({
                ...e,
                font: { size: 0, color: 'transparent' },
                color: { color: e.originalColor, opacity: 1.0 },
                // CAMBIA EL GROSOR AQUÍ TAMBIÉN (si querías que fueran más gruesas):
                width: 9
            }));
            this.edges.update(cleanEdges);
        }
    }
    
    showResult(message, type) {
        const resultDiv = document.getElementById('resultadoRuta');
        if (resultDiv) {
            resultDiv.classList.remove('d-none');
            resultDiv.className = `alert alert-${type} mb-4`;
            resultDiv.innerHTML = message;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => new GraphManager());
</script>
{% endblock %}